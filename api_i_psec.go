/*
VNS3 Controller API

Cohesive networks VNS3 provides complete control of your network's addressing, routes, rules and edge enabling a secure, connected and reactive cloud network. 

API version: 5.1.5
Contact: support@cohesive.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// IPsecApiService IPsecApi service
type IPsecApiService service

type ApiDeleteIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	endpointId int32
}

func (r ApiDeleteIpsecEndpointRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.DeleteIpsecEndpointExecute(r)
}

/*
DeleteIpsecEndpoint Delete IPsec endpoint

Delete IPsec endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiDeleteIpsecEndpointRequest
*/
func (a *IPsecApiService) DeleteIpsecEndpoint(ctx context.Context, endpointId int32) ApiDeleteIpsecEndpointRequest {
	return ApiDeleteIpsecEndpointRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return Object
func (a *IPsecApiService) DeleteIpsecEndpointExecute(r ApiDeleteIpsecEndpointRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.DeleteIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIpsecEndpointTunnelRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	endpointId int32
	tunnelId int32
}

func (r ApiDeleteIpsecEndpointTunnelRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.DeleteIpsecEndpointTunnelExecute(r)
}

/*
DeleteIpsecEndpointTunnel Delete IPsec tunnel

Delete IPsec tunnel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param tunnelId ID for tunnel
 @return ApiDeleteIpsecEndpointTunnelRequest
*/
func (a *IPsecApiService) DeleteIpsecEndpointTunnel(ctx context.Context, endpointId int32, tunnelId int32) ApiDeleteIpsecEndpointTunnelRequest {
	return ApiDeleteIpsecEndpointTunnelRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
		tunnelId: tunnelId,
	}
}

// Execute executes the request
//  @return Object
func (a *IPsecApiService) DeleteIpsecEndpointTunnelExecute(r ApiDeleteIpsecEndpointTunnelRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.DeleteIpsecEndpointTunnel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/tunnels/{tunnel_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tunnel_id"+"}", url.PathEscape(parameterToString(r.tunnelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectedSubnetsRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	extendedOutput *bool
}

// Receive verbose information about resources
func (r ApiGetConnectedSubnetsRequest) ExtendedOutput(extendedOutput bool) ApiGetConnectedSubnetsRequest {
	r.extendedOutput = &extendedOutput
	return r
}

func (r ApiGetConnectedSubnetsRequest) Execute() (*ConnectedSubnetsDetailResponse, *http.Response, error) {
	return r.ApiService.GetConnectedSubnetsExecute(r)
}

/*
GetConnectedSubnets Get connected subnets

Provides information about any connected subnets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConnectedSubnetsRequest
*/
func (a *IPsecApiService) GetConnectedSubnets(ctx context.Context) ApiGetConnectedSubnetsRequest {
	return ApiGetConnectedSubnetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectedSubnetsDetailResponse
func (a *IPsecApiService) GetConnectedSubnetsExecute(r ApiGetConnectedSubnetsRequest) (*ConnectedSubnetsDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectedSubnetsDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.GetConnectedSubnets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status/connected_subnets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.extendedOutput != nil {
		localVarQueryParams.Add("extended_output", parameterToString(*r.extendedOutput, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecDetailsRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
}

func (r ApiGetIpsecDetailsRequest) Execute() (*IpsecSystemDetail, *http.Response, error) {
	return r.ApiService.GetIpsecDetailsExecute(r)
}

/*
GetIpsecDetails Get IPsec details

Get details for all IPsec endpoints/subnets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIpsecDetailsRequest
*/
func (a *IPsecApiService) GetIpsecDetails(ctx context.Context) ApiGetIpsecDetailsRequest {
	return ApiGetIpsecDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpsecSystemDetail
func (a *IPsecApiService) GetIpsecDetailsExecute(r ApiGetIpsecDetailsRequest) (*IpsecSystemDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpsecSystemDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.GetIpsecDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	endpointId int32
}

func (r ApiGetIpsecEndpointRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.GetIpsecEndpointExecute(r)
}

/*
GetIpsecEndpoint Get IPsec endpoint

Get IPsec endpoint information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiGetIpsecEndpointRequest
*/
func (a *IPsecApiService) GetIpsecEndpoint(ctx context.Context, endpointId int32) ApiGetIpsecEndpointRequest {
	return ApiGetIpsecEndpointRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return Object
func (a *IPsecApiService) GetIpsecEndpointExecute(r ApiGetIpsecEndpointRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.GetIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecLinkHistoryRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	remote *string
	local *string
	tunnelid *int32
}

// Address string in CIDR format to display link history to a remote endpoint.
func (r ApiGetIpsecLinkHistoryRequest) Remote(remote string) ApiGetIpsecLinkHistoryRequest {
	r.remote = &remote
	return r
}

// Address string in CIDR format which will display status of the local route
func (r ApiGetIpsecLinkHistoryRequest) Local(local string) ApiGetIpsecLinkHistoryRequest {
	r.local = &local
	return r
}

// Will display link history of just the tunnel specified, which may be only one tunnel to a remote endpoint.
func (r ApiGetIpsecLinkHistoryRequest) Tunnelid(tunnelid int32) ApiGetIpsecLinkHistoryRequest {
	r.tunnelid = &tunnelid
	return r
}

func (r ApiGetIpsecLinkHistoryRequest) Execute() (*LinkHistoryDetail, *http.Response, error) {
	return r.ApiService.GetIpsecLinkHistoryExecute(r)
}

/*
GetIpsecLinkHistory Get IPsec link history

Provides information about the connection history of the subnet or tunnel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIpsecLinkHistoryRequest
*/
func (a *IPsecApiService) GetIpsecLinkHistory(ctx context.Context) ApiGetIpsecLinkHistoryRequest {
	return ApiGetIpsecLinkHistoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LinkHistoryDetail
func (a *IPsecApiService) GetIpsecLinkHistoryExecute(r ApiGetIpsecLinkHistoryRequest) (*LinkHistoryDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LinkHistoryDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.GetIpsecLinkHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status/link_history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.remote != nil {
		localVarQueryParams.Add("remote", parameterToString(*r.remote, ""))
	}
	if r.local != nil {
		localVarQueryParams.Add("local", parameterToString(*r.local, ""))
	}
	if r.tunnelid != nil {
		localVarQueryParams.Add("tunnelid", parameterToString(*r.tunnelid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecStatusRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	upDownStatusOnly *bool
}

// Only retrieve tunnel status. True is more performant but has less info. Defaults to false.
func (r ApiGetIpsecStatusRequest) UpDownStatusOnly(upDownStatusOnly bool) ApiGetIpsecStatusRequest {
	r.upDownStatusOnly = &upDownStatusOnly
	return r
}

func (r ApiGetIpsecStatusRequest) Execute() (*IpsecTunnelListResponseKeyValue, *http.Response, error) {
	return r.ApiService.GetIpsecStatusExecute(r)
}

/*
GetIpsecStatus Get IPsec status

Describe ipsec tunnels status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIpsecStatusRequest
*/
func (a *IPsecApiService) GetIpsecStatus(ctx context.Context) ApiGetIpsecStatusRequest {
	return ApiGetIpsecStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpsecTunnelListResponseKeyValue
func (a *IPsecApiService) GetIpsecStatusExecute(r ApiGetIpsecStatusRequest) (*IpsecTunnelListResponseKeyValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpsecTunnelListResponseKeyValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.GetIpsecStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upDownStatusOnly != nil {
		localVarQueryParams.Add("up_down_status_only", parameterToString(*r.upDownStatusOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	createIpsecEndpointRequest *CreateIpsecEndpointRequest
}

func (r ApiPostCreateIpsecEndpointRequest) CreateIpsecEndpointRequest(createIpsecEndpointRequest CreateIpsecEndpointRequest) ApiPostCreateIpsecEndpointRequest {
	r.createIpsecEndpointRequest = &createIpsecEndpointRequest
	return r
}

func (r ApiPostCreateIpsecEndpointRequest) Execute() (*IpsecRemoteEndpointDetail, *http.Response, error) {
	return r.ApiService.PostCreateIpsecEndpointExecute(r)
}

/*
PostCreateIpsecEndpoint Create IPsec endpoint

Create IPsec connection to the defined remote gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateIpsecEndpointRequest
*/
func (a *IPsecApiService) PostCreateIpsecEndpoint(ctx context.Context) ApiPostCreateIpsecEndpointRequest {
	return ApiPostCreateIpsecEndpointRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IpsecRemoteEndpointDetail
func (a *IPsecApiService) PostCreateIpsecEndpointExecute(r ApiPostCreateIpsecEndpointRequest) (*IpsecRemoteEndpointDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpsecRemoteEndpointDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.PostCreateIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIpsecEndpointRequest == nil {
		return localVarReturnValue, nil, reportError("createIpsecEndpointRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIpsecEndpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateIpsecEndpointTunnelRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	endpointId int32
	createIpsecTunnelRequest *CreateIpsecTunnelRequest
}

func (r ApiPostCreateIpsecEndpointTunnelRequest) CreateIpsecTunnelRequest(createIpsecTunnelRequest CreateIpsecTunnelRequest) ApiPostCreateIpsecEndpointTunnelRequest {
	r.createIpsecTunnelRequest = &createIpsecTunnelRequest
	return r
}

func (r ApiPostCreateIpsecEndpointTunnelRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.PostCreateIpsecEndpointTunnelExecute(r)
}

/*
PostCreateIpsecEndpointTunnel Create IPsec endpoint tunnel

Create IPsec endpoint tunnel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiPostCreateIpsecEndpointTunnelRequest
*/
func (a *IPsecApiService) PostCreateIpsecEndpointTunnel(ctx context.Context, endpointId int32) ApiPostCreateIpsecEndpointTunnelRequest {
	return ApiPostCreateIpsecEndpointTunnelRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return Object
func (a *IPsecApiService) PostCreateIpsecEndpointTunnelExecute(r ApiPostCreateIpsecEndpointTunnelRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.PostCreateIpsecEndpointTunnel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/tunnels"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.createIpsecTunnelRequest == nil {
		return localVarReturnValue, nil, reportError("createIpsecTunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIpsecTunnelRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRestartIpsecActionRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	restartRequest *RestartRequest
}

func (r ApiPostRestartIpsecActionRequest) RestartRequest(restartRequest RestartRequest) ApiPostRestartIpsecActionRequest {
	r.restartRequest = &restartRequest
	return r
}

func (r ApiPostRestartIpsecActionRequest) Execute() (*RestartStatus, *http.Response, error) {
	return r.ApiService.PostRestartIpsecActionExecute(r)
}

/*
PostRestartIpsecAction Restart ipsec subystem

Restart ipsec subystem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRestartIpsecActionRequest
*/
func (a *IPsecApiService) PostRestartIpsecAction(ctx context.Context) ApiPostRestartIpsecActionRequest {
	return ApiPostRestartIpsecActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RestartStatus
func (a *IPsecApiService) PostRestartIpsecActionExecute(r ApiPostRestartIpsecActionRequest) (*RestartStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestartStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.PostRestartIpsecAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restartRequest == nil {
		return localVarReturnValue, nil, reportError("restartRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restartRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecConfigRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	updateIpsecAddressRequest *UpdateIpsecAddressRequest
}

func (r ApiPutUpdateIpsecConfigRequest) UpdateIpsecAddressRequest(updateIpsecAddressRequest UpdateIpsecAddressRequest) ApiPutUpdateIpsecConfigRequest {
	r.updateIpsecAddressRequest = &updateIpsecAddressRequest
	return r
}

func (r ApiPutUpdateIpsecConfigRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecConfigExecute(r)
}

/*
PutUpdateIpsecConfig Update IPsec config

Edit Ipsec Configuration on device. Note, This is device wide and must be set before  any remote endpoint definitions are created. If it needs to be changed, all remote endpoint  information and tunnel information must be deleted first.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutUpdateIpsecConfigRequest
*/
func (a *IPsecApiService) PutUpdateIpsecConfig(ctx context.Context) ApiPutUpdateIpsecConfigRequest {
	return ApiPutUpdateIpsecConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Object
func (a *IPsecApiService) PutUpdateIpsecConfigExecute(r ApiPutUpdateIpsecConfigRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.PutUpdateIpsecConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIpsecAddressRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecAddressRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	endpointId int32
	updateIpsecConnectionRequest *UpdateIpsecConnectionRequest
}

func (r ApiPutUpdateIpsecEndpointRequest) UpdateIpsecConnectionRequest(updateIpsecConnectionRequest UpdateIpsecConnectionRequest) ApiPutUpdateIpsecEndpointRequest {
	r.updateIpsecConnectionRequest = &updateIpsecConnectionRequest
	return r
}

func (r ApiPutUpdateIpsecEndpointRequest) Execute() (*Object, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecEndpointExecute(r)
}

/*
PutUpdateIpsecEndpoint Update IPsec endpoint

Edit IPsec endpoint connection configuration parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiPutUpdateIpsecEndpointRequest
*/
func (a *IPsecApiService) PutUpdateIpsecEndpoint(ctx context.Context, endpointId int32) ApiPutUpdateIpsecEndpointRequest {
	return ApiPutUpdateIpsecEndpointRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return Object
func (a *IPsecApiService) PutUpdateIpsecEndpointExecute(r ApiPutUpdateIpsecEndpointRequest) (*Object, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Object
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.PutUpdateIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.updateIpsecConnectionRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecConnectionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecConnectionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecEndpointTunnelRequest struct {
	ctx context.Context
	ApiService *IPsecApiService
	endpointId int32
	tunnelId int32
	updateIpsecTunnelRequest *UpdateIpsecTunnelRequest
}

func (r ApiPutUpdateIpsecEndpointTunnelRequest) UpdateIpsecTunnelRequest(updateIpsecTunnelRequest UpdateIpsecTunnelRequest) ApiPutUpdateIpsecEndpointTunnelRequest {
	r.updateIpsecTunnelRequest = &updateIpsecTunnelRequest
	return r
}

func (r ApiPutUpdateIpsecEndpointTunnelRequest) Execute() (*IpsecTunnelDetail, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecEndpointTunnelExecute(r)
}

/*
PutUpdateIpsecEndpointTunnel Update IPsec endpoint tunnel

Edit IPsec endpoint tunnel configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param tunnelId ID for tunnel
 @return ApiPutUpdateIpsecEndpointTunnelRequest
*/
func (a *IPsecApiService) PutUpdateIpsecEndpointTunnel(ctx context.Context, endpointId int32, tunnelId int32) ApiPutUpdateIpsecEndpointTunnelRequest {
	return ApiPutUpdateIpsecEndpointTunnelRequest{
		ApiService: a,
		ctx: ctx,
		endpointId: endpointId,
		tunnelId: tunnelId,
	}
}

// Execute executes the request
//  @return IpsecTunnelDetail
func (a *IPsecApiService) PutUpdateIpsecEndpointTunnelExecute(r ApiPutUpdateIpsecEndpointTunnelRequest) (*IpsecTunnelDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IpsecTunnelDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IPsecApiService.PutUpdateIpsecEndpointTunnel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/tunnels/{tunnel_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tunnel_id"+"}", url.PathEscape(parameterToString(r.tunnelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.updateIpsecTunnelRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecTunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecTunnelRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Object
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
